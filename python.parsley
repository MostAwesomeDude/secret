# Omissions:
# * ``
# * <>

# http://docs.python.org/reference/lexical_analysis.html

# 2.3
identifier = spaces? (letter | '_'):first <letterOrDigit*>:second
             ?(not self.keyword_pred(first, second))
           -> t.Identifier(first + second)
letter = lowercase | uppercase
lowercase = anything:c ?(c in "abcdefghijklmnopqrstuvwxyz") -> c
uppercase = anything:c ?(c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ") -> c
digit = anything:c ?(c in "0123456789") -> c

# 2.3.1
keyword :k = token(k) ~letterOrDigit -> k

# 2.4.1
stringliteral = spaces? stringprefix?:p (longstring | shortstring):s
              -> t.Str(p, s)
stringprefix = 'r' | 'u' | "ur" | 'R' | 'U' | "UR" | "Ur" | "uR" | 'b' | 'B'
             | "br" | "Br" | "bR" | "BR"
shortstring = shortstringsingle | shortstringdouble
shortstringsingle = '\'' <(escapeseq | ~'\'' ~'\n' anything)*>:s '\'' -> s
shortstringdouble = '"' <(escapeseq | ~'"' ~'\n' anything)*>:s '"' -> s
longstring = '\'' '\'' '\'' <longstringitem*>:s '\'' '\'' '\'' -> s
           | '"' '"' '"' <longstringitem*>:s '"' '"' '"' -> s
longstringitem = longstringchar | escapeseq
longstringchar = ~'\\'
escapeseq = '\\' anything

# 2.4.4
longinteger = integer:i ('l' | 'L') -> i
integer = spaces? (octinteger | hexinteger | bininteger | decimalinteger):i
        -> t.Num(i)
decimalinteger = nonzerodigit:first <digit*>:second -> int(first + second)
               | '0' -> 0
octinteger = '0' ('o' | 'O') <octdigit+>:d -> int(d, 8)
           | '0' <octdigit+>:d -> int(d, 8)
hexinteger = '0' ('x' | 'X') <hexdigit+>:d -> int(d, 16)
bininteger = '0' ('b' | 'B') <bindigit+>:d -> int(d, 2)
nonzerodigit = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
octdigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
bindigit = '0' | '1'
hexdigit = digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D'
         | 'E' | 'F'

# 2.4.5
floatnumber = pointfloat | exponentfloat
pointfloat = intpart? fraction | intpart '.'
exponentfloat = (intpart | pointfloat) exponent
intpart = digit+
fraction = '.' digit+
exponent = ('e' | 'E') ('+' | '-')? digit+

# 2.4.6
imagnumber = (floatnumber | intpart) ('j' | 'J')

# http://docs.python.org/reference/expressions.html

# 5.2
atom = identifier | literal | enclosure
enclosure = parenth_form | list_display | generator_expression | dict_display
          | set_display | yield_atom

# 5.2.2
literal = stringliteral | longinteger | integer | imagnumber | floatnumber

# 5.2.3
parenth_form = token("(") expression_list?:e token(")")
             -> t.Tuple(*e) if e and len(e) > 1 else e if e else t.Tuple()

# 5.2.4, 5.2.5
# We generalize comprehensions entirely.
list_display = token("[") expression_list?:l token("]") -> t.List(*l)
             | token("[") list_comprehension:l token("]") -> l
list_comprehension = expression:e list_for:f -> l.ListComp(e, f)
comp_for = keyword("for") target_list:t keyword("in") expression_list:i
           list_iter?:f
         -> l.Comprehension(t, i, f)
comp_iter = comp_for | comp_if
comp_if = keyword("if") expression:e comp_iter?:f -> l.CompIf(e, f)

# 5.2.6
generator_expression = token("(") expression:e comp_for:c token(")")
                     -> t.Generator(e, c)

# 5.2.7
dict_display = token("{") (key_datum_list | dict_comprehension)?:e token("}")
             -> t.Dict(e)
key_datum_list = key_datum:head (token(",") key_datum)*:tail token(",")?
               -> [head] + tail
key_datum = expression:k token(":") expression:v -> t.Pair(k, v)
dict_comprehension = expression:k token(":") expression:v comp_for:c
                   -> t.Comprehension(k, v, c)

# 5.2.8
set_display = token("{") expression_list:e token("}") -> t.Set(*e)
            | token("{") list_comprehension:e token("}") -> t.Set(e)

# 5.2.10
yield_atom = token("(") yield_expression:e token(")") -> e
yield_expression = keyword("yield") expression_list?:e -> t.Yield(e)

# 5.3
primary = atom | attributeref | subscription | slicing | call

# 5.3.1
attributeref = primary token(".") identifier -> t.Attribute(primary, identifier)

# 5.3.2
subscription = primary:obj token("[") expression_list:item token("]")
             -> t.Subscript(obj, item)

# 5.3.3
slicing = simple_slicing | extended_slicing
simple_slicing = primary:obj token("[") short_slice:s token("]")
               -> t.Subscript(obj, s)
extended_slicing = primary:obj token("[") short_list:s token("]")
                 -> t.Subscript(obj, s)
slice_list = slice_item:head (token(",") slice_item)*:tail token(",")?
           -> [head] + tail
slice_item = ellipsis | proper_slice | expression
proper_slice = long_slice | short_slice
short_slice = lower_bound?:lower token(":") upper_bound?:upper
            -> t.Slice(lower, upper, t.Num(1))
long_slice = short_slice:s token(":") stride?:st -> t.Slice(s, st)
lower_bound = expression
upper_bound = expression
stride = expression
ellipsis = token("...") -> t.Ellipsis()

# 5.3.4
call = primary:f token("(")
       (argument_list token(",")? | expression genexpr_for)?:args token(")")
     -> t.Call(f, args)
argument_list = positional_arguments:args
                (token(",") keyword_arguments)?:kwargs
                (token(",") token("*") expression)?:starargs
                (token(",") keyword_arguments)?:morekwargs
                (token(",") token("**") expression)?:starkwargs
                -> t.Arguments(args, kwargs + morekwargs, starargs, starkwargs)
              | keyword_arguments:kwargs
                (token(",") token("*") expression)?:starargs
                (token(",") token("**") expression)?:starkwargs
                -> t.Arguments(None, kwargs, starargs, starkwargs)
              | token("*") expression:starargs
                (token(",") token("*") expression)?:morestarargs
                (token(",") token("**") expression)?:starkwargs
                -> t.Arguments(starargs, None, morestarargs, starkwargs)
              | token("**") expression:kwargs
                -> t.Arguments(None, None, None, kwargs)
positional_arguments = expression:head (token(",") expression)*:tail
                     -> [head] + tail
keyword_arguments = keyword_item:head (token(",") keyword_item)*:tail
                  -> [head] + tail
keyword_item = identifier:k token("=") expression:v -> t.Pair(k, v)

# 5.4
power = primary:left (token("**") u_expr)?:right
      -> t.Pow(left, right) if right else left

# 5.5
u_expr = token("-") u_expr:e -> t.Negate(e)
       | token("+") u_expr
       | token("~") u_expr:e -> t.Invert(e)
       | power

# 5.6
m_expr = m_expr:left token("*") u_expr:right -> t.Mult(left, right)
       | m_expr:left token("//") u_expr:right -> t.FloorDiv(left, right)
       | m_expr:left token("/") u_expr:right -> t.Div(left, right)
       | m_expr:left token("%") u_expr:right -> t.Mod(left, right)
       | u_expr
a_expr = a_expr:left token("+") m_expr:right -> t.Add(left, right)
       | a_expr:left token("-") m_expr:right -> t.Sub(left, right)
       | m_expr

# 5.7
shift_expr = shift_expr:left token("<<") a_expr:right -> t.LShift(left, right)
           | shift_expr:left token(">>") a_expr:right -> t.RShift(left, right)
           | a_expr

# 5.8
and_expr = and_expr:left token("&") shift_expr:right -> t.BitAnd(left, right)
         | shift_expr
xor_expr = xor_expr:left token("^") and_expr:right -> t.BitXor(left, right)
         | and_expr
or_expr = or_expr:left token("|") xor_expr:right -> t.BitOr(left, right)
        | xor_expr

# 5.9
comparison = or_expr:left (cmpop:c or_expr:e -> t.Pair(c, e))+:right
           -> t.Compare(left, right)
           | or_expr
# Precedence: isnot must be matched before is.
cmpop = eq | noteq | lt | lte | gt | gte | isnot | is | in | notin
eq = token("==") -> t.Eq()
noteq = token("!=") -> t.NotEq()
lt = token("<") -> t.Lt()
lte = token("<=") -> t.LtE()
gt = token(">") -> t.Gt()
gte = token(">=") -> t.GtE()
is = keyword("is") -> t.Is()
isnot = keyword("is") keyword("not") -> t.IsNot()
in = keyword("in") -> t.In()
notin = keyword("not") keyword("in") -> t.NotIn()

# 5.10
or_test = or_test:left keyword("or") and_test:right
          -> t.Or(left, right)
        | and_test
and_test = and_test:left keyword("and") not_test:right
           -> t.And(left, right)
         | not_test
not_test = comparison | keyword("not") not_test:e -> t.Not(e)

# 5.11
conditional_expression = or_test:left keyword("if") or_test:cond
                         keyword("else") expression:right
                         -> t.IfExp(cond, left, right)
                       | or_test
expression = conditional_expression | lambda_form

# 5.12
lambda_form = keyword("lambda") parameter_list?:p token(":") expression:e
            -> t.Lambda(p, e)

# 5.13
expression_list = expression:head (token(",") expression)*:tail token(",")?
                -> [head] + tail
