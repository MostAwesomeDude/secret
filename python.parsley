# Omissions:
# * ``
# * <>

# Core primitives that will be needed later.
NEWLINE = '\r' '\n' | '\r' | '\n' -> None
spaces = (' ' | '\t')* -> None

# http://docs.python.org/reference/lexical_analysis.html

# 2.3
identifier = spaces? (letter | '_'):first <letterOrDigit*>:second
             ?(not self.keyword_pred(first, second))
           -> t.Identifier(first + second)
letter = lowercase | uppercase
lowercase = anything:c ?(c in "abcdefghijklmnopqrstuvwxyz") -> c
uppercase = anything:c ?(c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ") -> c
digit = anything:c ?(c in "0123456789") -> c

# 2.3.1
keyword :k = token(k) ~letterOrDigit -> k

# 2.4.1
stringliteral = spaces? stringprefix?:p (longstring | shortstring):s
              -> t.Str(p, s)
stringprefix = 'r' | 'u' | "ur" | 'R' | 'U' | "UR" | "Ur" | "uR" | 'b' | 'B'
             | "br" | "Br" | "bR" | "BR"
shortstring = shortstringsingle | shortstringdouble
shortstringsingle = '\'' <(escapeseq | ~'\'' ~'\n' anything)*>:s '\'' -> s
shortstringdouble = '"' <(escapeseq | ~'"' ~'\n' anything)*>:s '"' -> s
longstring = '\'' '\'' '\'' <longstringitem*>:s '\'' '\'' '\'' -> s
           | '"' '"' '"' <longstringitem*>:s '"' '"' '"' -> s
longstringitem = longstringchar | escapeseq
longstringchar = ~'\\'
escapeseq = '\\' anything

# 2.4.4
longinteger = integer:i ('l' | 'L') -> i
integer = spaces? (octinteger | hexinteger | bininteger | decimalinteger):i
        -> t.Num(i)
decimalinteger = nonzerodigit:first <digit*>:second -> int(first + second)
               | '0' -> 0
octinteger = '0' ('o' | 'O') <octdigit+>:d -> int(d, 8)
           | '0' <octdigit+>:d -> int(d, 8)
hexinteger = '0' ('x' | 'X') <hexdigit+>:d -> int(d, 16)
bininteger = '0' ('b' | 'B') <bindigit+>:d -> int(d, 2)
nonzerodigit = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
octdigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
bindigit = '0' | '1'
hexdigit = digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D'
         | 'E' | 'F'

# 2.4.5
floatnumber = pointfloat | exponentfloat
pointfloat = intpart? fraction | intpart '.'
exponentfloat = (intpart | pointfloat) exponent
intpart = digit+
fraction = '.' digit+
exponent = ('e' | 'E') ('+' | '-')? digit+

# 2.4.6
imagnumber = (floatnumber | intpart) ('j' | 'J')

# http://docs.python.org/reference/expressions.html

# 5.2
atom = identifier | literal | enclosure
enclosure = parenth_form | list_display | generator_expression | dict_display
          | set_display | yield_atom

# 5.2.2
literal = stringliteral | longinteger | integer | imagnumber | floatnumber

# 5.2.3
parenth_form = token("(") expression_list?:e token(")")
             -> t.Tuple(*e) if e and len(e) > 1 else e if e else t.Tuple()

# 5.2.4, 5.2.5
# We generalize comprehensions entirely.
list_display = token("[") expression_list?:l token("]") -> t.List(*l)
             | token("[") list_comprehension:l token("]") -> l
list_comprehension = expression:e list_for:f -> l.ListComp(e, f)
comp_for = keyword("for") target_list:t keyword("in") expression_list:i
           list_iter?:f
         -> l.Comprehension(t, i, f)
comp_iter = comp_for | comp_if
comp_if = keyword("if") expression:e comp_iter?:f -> l.CompIf(e, f)

# 5.2.6
generator_expression = token("(") expression:e comp_for:c token(")")
                     -> t.Generator(e, c)

# 5.2.7
dict_display = token("{") key_datum_list?:e token("}")
               -> t.Dict(*e) if e else t.Dict()
             | token("{") dict_comprehension:e token("}") -> t.Dict(e)
key_datum_list = key_datum:head (token(",") key_datum)*:tail token(",")?
               -> [head] + tail
key_datum = expression:k token(":") expression:v -> t.Pair(k, v)
dict_comprehension = expression:k token(":") expression:v comp_for:c
                   -> t.Comprehension(k, v, c)

# 5.2.8
set_display = token("{") expression_list:e token("}") -> t.Set(*e)
            | token("{") list_comprehension:e token("}") -> t.Set(e)

# 5.2.10
yield_atom = token("(") yield_expression:e token(")") -> e
yield_expression = keyword("yield") expression_list?:e -> t.Yield(e)

# 5.3
primary = atom | attributeref | subscription | slicing | call

# 5.3.1
attributeref = primary token(".") identifier -> t.Attribute(primary, identifier)

# 5.3.2
subscription = primary:obj token("[") expression_list:item token("]")
             -> t.Subscript(obj, item)

# 5.3.3
slicing = simple_slicing | extended_slicing
simple_slicing = primary:obj token("[") short_slice:s token("]")
               -> t.Subscript(obj, s)
extended_slicing = primary:obj token("[") short_list:s token("]")
                 -> t.Subscript(obj, s)
slice_list = slice_item:head (token(",") slice_item)*:tail token(",")?
           -> [head] + tail
slice_item = ellipsis | proper_slice | expression
proper_slice = long_slice | short_slice
short_slice = lower_bound?:lower token(":") upper_bound?:upper
            -> t.Slice(lower, upper, t.Num(1))
long_slice = short_slice:s token(":") stride?:st -> t.Slice(s, st)
lower_bound = expression
upper_bound = expression
stride = expression
ellipsis = token("...") -> t.Ellipsis()

# 5.3.4
call = primary:f token("(")
       (argument_list token(",")? | expression genexpr_for)?:args token(")")
     -> t.Call(f, args)
argument_list = positional_arguments:args
                (token(",") keyword_arguments)?:kwargs
                (token(",") token("*") expression)?:starargs
                (token(",") keyword_arguments)?:morekwargs
                (token(",") token("**") expression)?:starkwargs
                -> t.Arguments(args, kwargs + morekwargs, starargs, starkwargs)
              | keyword_arguments:kwargs
                (token(",") token("*") expression)?:starargs
                (token(",") token("**") expression)?:starkwargs
                -> t.Arguments(None, kwargs, starargs, starkwargs)
              | token("*") expression:starargs
                (token(",") token("*") expression)?:morestarargs
                (token(",") token("**") expression)?:starkwargs
                -> t.Arguments(starargs, None, morestarargs, starkwargs)
              | token("**") expression:kwargs
                -> t.Arguments(None, None, None, kwargs)
positional_arguments = expression:head (token(",") expression)*:tail
                     -> [head] + tail
keyword_arguments = keyword_item:head (token(",") keyword_item)*:tail
                  -> [head] + tail
keyword_item = identifier:k token("=") expression:v -> t.Pair(k, v)

# 5.4
power = primary:left (token("**") u_expr)?:right
      -> t.Pow(left, right) if right else left

# 5.5
u_expr = token("-") u_expr:e -> t.Negate(e)
       | token("+") u_expr
       | token("~") u_expr:e -> t.Invert(e)
       | power

# 5.6
m_expr = m_expr:left token("*") u_expr:right -> t.Mult(left, right)
       | m_expr:left token("//") u_expr:right -> t.FloorDiv(left, right)
       | m_expr:left token("/") u_expr:right -> t.Div(left, right)
       | m_expr:left token("%") u_expr:right -> t.Mod(left, right)
       | u_expr
a_expr = a_expr:left token("+") m_expr:right -> t.Add(left, right)
       | a_expr:left token("-") m_expr:right -> t.Sub(left, right)
       | m_expr

# 5.7
shift_expr = shift_expr:left token("<<") a_expr:right -> t.LShift(left, right)
           | shift_expr:left token(">>") a_expr:right -> t.RShift(left, right)
           | a_expr

# 5.8
and_expr = and_expr:left token("&") shift_expr:right -> t.BitAnd(left, right)
         | shift_expr
xor_expr = xor_expr:left token("^") and_expr:right -> t.BitXor(left, right)
         | and_expr
or_expr = or_expr:left token("|") xor_expr:right -> t.BitOr(left, right)
        | xor_expr

# 5.9
comparison = or_expr:left (cmpop:c or_expr:e -> t.Pair(c, e))+:right
           -> t.Compare(left, right)
           | or_expr
# Precedence: isnot must be matched before is.
cmpop = eq | noteq | lt | lte | gt | gte | isnot | is | in | notin
eq = token("==") -> t.Eq()
noteq = token("!=") -> t.NotEq()
lt = token("<") -> t.Lt()
lte = token("<=") -> t.LtE()
gt = token(">") -> t.Gt()
gte = token(">=") -> t.GtE()
is = keyword("is") -> t.Is()
isnot = keyword("is") keyword("not") -> t.IsNot()
in = keyword("in") -> t.In()
notin = keyword("not") keyword("in") -> t.NotIn()

# 5.10
or_test = or_test:left keyword("or") and_test:right
          -> t.Or(left, right)
        | and_test
and_test = and_test:left keyword("and") not_test:right
           -> t.And(left, right)
         | not_test
not_test = keyword("not") not_test:e -> t.Not(e)
         | comparison

# 5.11
conditional_expression = or_test:left keyword("if") or_test:cond
                         keyword("else") expression:right
                         -> t.IfExp(cond, left, right)
                       | or_test
expression = conditional_expression | lambda_form

# 5.12
lambda_form = keyword("lambda") parameter_list?:p token(":") expression:e
            -> t.Lambda(p, e)

# 5.13
expression_list = expression:head (token(",") expression)*:tail token(",")?
                -> [head] + tail

# http://docs.python.org/reference/simple_stmts.html

# 6
simple_stmt = expression_stmt
            | assert_stmt
            | assignment_stmt
            | augmented_assignment_stmt
            | pass_stmt
            | del_stmt
            | print_stmt
            | return_stmt
            | yield_stmt
            | raise_stmt
            | break_stmt
            | continue_stmt
            | import_stmt
            | global_stmt
            | exec_stmt

# 6.1
expression_stmt = expression_list

# 6.2
# XXX ast
assignment_stmt = (target_list token("="))+ (expression_list | yield_expression)
target_list = target (token(",") target)* token(",")?
target = identifier
       | token("(") target_list token(")")
       | token("[") target_list token("]")
       | attributeref
       | subscription
       | slicing

# 6.2.1
# XXX ast
augmented_assignment_stmt = augtarget augop (expression_list | yield_expression)
augtarget = identifier | attributeref | subscription | slicing
augop = token("+=") | token("-=") | token("*=") | token("/=") | token("//=")
      | token("%=") | token("**=") | token(">>=") | token("<<=") | token("&=")
      | token("^=") | token("|=")

# 6.3
# XXX ast
assert_stmt = keyword("assert") expression (token(",") expression)?

# 6.4
pass_stmt = keyword("pass") -> t.Pass()

# 6.5
del_stmt = keyword("del") target_list:t -> t.Del(t)

# 6.6
# XXX ast
# XXX oh noes, do we even want this? :T
print_stmt = keyword("print")
             ((expression (token(",") expression)* token(",")?)
             | token(">>") expression (token(",") expression)+ token(",")?)

# 6.7
return_stmt = keyword("return") expression_list?:rv -> t.Return(rv)

# 6.8
yield_stmt = yield_expression

# 6.9
raise_stmt = keyword("raise")
             (expression:t
              (token(",") expression:v (token(",") expression:tb)?)?)?
           -> t.Raise(t, v, tb)

# 6.10
break_stmt = keyword("break") -> t.Break()

# 6.11
continue_stmt = keyword("continue") -> t.Continue()

# 6.12
# We don't have the "name" rule; it's only used immediately after the "as"
# keyword, so we instead have a single "as_name" rule which inlines "name".
# For posterity, this is "name":
# name = identifier
# ...Yeah, that's why.
# XXX ast
import_stmt = keyword("import") module as_name? (token(",") module as_name)*
            | keyword("from") relative_module keyword("import") identifier
              as_name (token(",") identifier as_name)*
            | keyword("from") relative_module keyword("import") token("(")
              identifier as_name (token(",") identifier as_name)* token(",")?
              token(")")
module = (identifier token("."))* identifier
relative_module = token(".")* module | token(".")+
as_name = keyword("as") identifier:n -> t.As(n)

# 6.12.1
# XXX ast
future_statement = keyword("from") token("__future__") keyword("import")
                   feature as_name? (token(",") feature as_name?)*
                 | keyword("from") token("__future__") keyword("import")
                   token("(") feature as_name? (token(",") feature as_name?)*
                   token(",")? token(")")
feature = identifier

# 6.13
# XXX ast
global_stmt = keyword("global") identifier (token(",") identifier)*

# 6.14
# XXX ast
exec_stmt = keyword("exec") or_expr
            (keyword("in") expression (token(",") expression)?)?

# http://docs.python.org/reference/compound_stmts.html

# 7
# XXX ast
compound_stmt = if_stmt
              | while_stmt
              | for_stmt
              | try_stmt
              | with_stmt
              | funcdef
              | classdef
              | decorated
suite = stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
statement = stmt_list NEWLINE | compound_stmt
stmt_list = simple_stmt (token(";") simple_stmt)* token(";")?

# 7.1
# XXX ast
if_stmt = keyword("if") expression token(":") suite
          (keyword("elif") expression token(":") suite)*
          (keyword("else") token(":") suite)?

# 7.2
# XXX ast
while_stmt = keyword("while") expression token(":") suite

# 7.3
# XXX ast
for_stmt = keyword("for") target_list keyword("in") expression_list token(":")
           suite (keyword("else") token(":") suite)?

# 7.4
# XXX ast
try_stmt = try1_stmt | try2_stmt
try1_stmt = keyword("try") token(":") suite
            (keyword("except")
             (expression ((keyword("as") | token(",")) target)?)? token(":")
              suite)+
            (keyword("else") token(":") suite)?
            (keyword("finally") token(":") suite)?
try2_stmt = keyword("try") token(":") suite
            keyword("finally") token(":") suite

# 7.5
# XXX ast
with_stmt = keyword("with") with_item (token(",") with_item)* token(":") suite
with_item = expression (keyword("as") target)?

# 7.6
# XXX ast
decorated = decorators (classdef | funcdef)
decorators = decorator+
decorator = token("@") dotted_name
            (token("(") (argument_list token(",")?)? token(")"))? NEWLINE
funcdef = keyword("def") funcname token("(") parameter_list? token(")")
          token(":") suite
dotted_name = identifier (token(".") identifier)*
parameter_list = (defparameter token(","))*
                 (token("*") identifier (token(",") token("**") identifier)?
                | token("**") identifier
                | defparameter token(",")?)
defparameter = parameter (token("=") expression)?
sublist = parameter (token(",") parameter)* token(",")?
parameter = identifier | token("(") sublist token(")")
funcname = identifier

# 7.7
# XXX ast
classdef = keyword("class") classname inheritance? token(":") suite
inheritance = token("(") expression_list? token(")")
classname = identifier

# http://docs.python.org/reference/toplevel_components.html

# 8.2
file_input = (NEWLINE | statement)*
