# Omissions:
# * ``
# * <>

# http://docs.python.org/reference/lexical_analysis.html

# 2.3
identifier = spaces? (letter | '_'):first <letterOrDigit*>:second
             ?(not self.keyword_pred(first, second))
           -> t.Identifier(first + second)
letter = lowercase | uppercase
lowercase = anything:c ?(c in "abcdefghijklmnopqrstuvwxyz") -> c
uppercase = anything:c ?(c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ") -> c
digit = anything:c ?(c in "0123456789") -> c

# 2.3.1
keyword :k = token(k) ~letterOrDigit -> k

# 2.4.1
stringliteral = spaces? stringprefix?:p (longstring | shortstring):s
              -> t.Str(p, s)
stringprefix = 'r' | 'u' | "ur" | 'R' | 'U' | "UR" | "Ur" | "uR" | 'b' | 'B'
             | "br" | "Br" | "bR" | "BR"
shortstring = shortstringsingle | shortstringdouble
shortstringsingle = '\'' <(escapeseq | ~'\'' ~'\n' anything)*>:s '\'' -> s
shortstringdouble = '"' <(escapeseq | ~'"' ~'\n' anything)*>:s '"' -> s
longstring = '\'' '\'' '\'' <longstringitem*>:s '\'' '\'' '\'' -> s
           | '"' '"' '"' <longstringitem*>:s '"' '"' '"' -> s
longstringitem = longstringchar | escapeseq
longstringchar = ~'\\'
escapeseq = '\\' anything

# 2.4.4
longinteger = integer:i ('l' | 'L') -> i
integer = spaces? (octinteger | hexinteger | bininteger | decimalinteger):i
        -> t.Num(i)
decimalinteger = nonzerodigit:first <digit*>:second -> int(first + second)
               | '0' -> 0
octinteger = '0' ('o' | 'O') <octdigit+>:d -> int(d, 8)
           | '0' <octdigit+>:d -> int(d, 8)
hexinteger = '0' ('x' | 'X') <hexdigit+>:d -> int(d, 16)
bininteger = '0' ('b' | 'B') <bindigit+>:d -> int(d, 2)
nonzerodigit = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
octdigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
bindigit = '0' | '1'
hexdigit = digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D'
         | 'E' | 'F'

# 2.4.5
floatnumber = pointfloat | exponentfloat
pointfloat = intpart? fraction | intpart '.'
exponentfloat = (intpart | pointfloat) exponent
intpart = digit+
fraction = '.' digit+
exponent = ('e' | 'E') ('+' | '-')? digit+

# 2.4.6
imagnumber = (floatnumber | intpart) ('j' | 'J')

# http://docs.python.org/reference/expressions.html

# 5.2
atom = identifier | literal | enclosure
enclosure = parenth_form | list_display | generator_expression | dict_display
          | set_display | string_conversion | yield_atom

# 5.2.2
literal = stringliteral | longinteger | integer | imagnumber | floatnumber

# 5.2.3
parenth_form = token("(") expression_list?:e token(")") -> e

# 5.2.4
# XXX need to pull out all the data and AST it
list_display = token("[") (expression_list | list_comprehension)?:l token("]")
             -> l
list_comprehension = expression list_for
list_for = keyword("for") target_list keyword ("in") old_expression_list list_iter?
old_expression_list = old_expression ((token(",") old_expression)+ token(",")?)?
old_expression = or_test | old_lambda_form
list_iter = list_for | list_if
list_if = keyword("if") old_expression list_iter?

# 5.2.5
# XXX AST
comprehension = expression comp_for
comp_for = keyword("for") target_list keyword("in") or_test comp_iter?
comp_iter = comp_for | comp_if
comp_if = keyword("if") expression_nocond comp_iter?

# 5.2.6
# XXX AST
generator_expression = token("(") expression comp_for token(")")

# 5.2.7
# XXX AST
dict_display = token("{") (key_datum_list | dict_comprehension)? token("}")
key_datum_list = key_datum (token(",") key_datum)* token(",")?
key_datum = expression token(":") expression
dict_comprehension = expression token(":") expression comp_for

# 5.2.8
# XXX AST
set_display = token("{") (expression_list | comprehension) token("}")

# 5.2.9
# XXX this should get nuked someday.
string_conversion = token("`") expression_list:e token("`") -> e

# 5.2.10
# XXX AST
yield_atom = token("(") yield_expression:e token(")") -> e
yield_expression = keyword("yield") expression_list?

# 5.3
# XXX AST
primary = atom | attributeref | subscription | slicing | call

# 5.3.1
attributeref = primary token(".") identifier -> t.Attribute(primary, identifier)

# 5.3.2
# XXX AST
subscription = primary token("[") expression_list token("]")

# 5.3.3
# XXX AST
slicing = simple_slicing | extended_slicing
simple_slicing = primary token("[") short_slice token("]")
extended_slicing = primary token("[") short_list token("]")
slice_list = slice_item (token(",") slice_item)* token(",")?
slice_item = expression | proper_slice | ellipsis
proper_slice = short_slice | long_slice
short_slice = lower_bound? token(":") upper_bound?
long_slice = short_slice token(":") stride?
lower_bound = expression
upper_bound = expression
stride = expression
ellipsis = token("...") -> t.Ellipsis()

# 5.3.4
# XXX AST
call = primary token("(")
       (argument_list token(",")? | expression genexpr_for)? token(")")
argument_list = positional_arguments (token(",") keyword_arguments)?
                (token(",") token("*") expression)?
                (token(",") keyword_arguments)?
                (token(",") token("**") expression)?
              | keyword_arguments (token(",") token("*") expression)?
                (token(",") token("**") expression)?
              | token("*") expression (token(",") token("*") expression)?
                (token(",") token("**") expression)?
              | token("**") expression
positional_arguments = expression (token(",") expression)*
keyword_arguments = keyword_item (token(",") keyword_item)*
keyword_item = identifier token("=") expression

# 5.4
power = primary:left (token("**") u_expr)?:right
      -> t.Pow(left, right) if right else left

# 5.5
u_expr = token("-") u_expr:e -> t.Negate(e)
       | token("+") u_expr
       | token("~") u_expr:e -> t.Invert(e)
       | power

# 5.6
m_expr = m_expr:left token("*") u_expr:right -> t.Mult(left, right)
       | m_expr:left token("//") u_expr:right -> t.FloorDiv(left, right)
       | m_expr:left token("/") u_expr:right -> t.Div(left, right)
       | m_expr:left token("%") u_expr:right -> t.Mod(left, right)
       | u_expr
a_expr = a_expr:left token("+") m_expr:right -> t.Add(left, right)
       | a_expr:left token("-") m_expr:right -> t.Sub(left, right)
       | m_expr

# 5.7
shift_expr = shift_expr:left token("<<") a_expr:right -> t.LShift(left, right)
           | shift_expr:left token(">>") a_expr:right -> t.RShift(left, right)
           | a_expr

# 5.8
and_expr = and_expr:left token("&") shift_expr:right -> t.BitAnd(left, right)
         | shift_expr
xor_expr = xor_expr:left token("^") and_expr:right -> t.BitXor(left, right)
         | and_expr
or_expr = or_expr:left token("|") xor_expr:right -> t.BitOr(left, right)
        | xor_expr

# 5.9
# Precedence: isnot must be matched before is.
comparison = or_expr:left (cmpop or_expr)*:right -> t.Compare(left, right)
cmpop = eq | noteq | lt | lte | gt | gte | isnot | is | in | notin
eq = token("==") -> t.Eq()
noteq = token("!=") -> t.NotEq()
lt = token("<") -> t.Lt()
lte = token("<=") -> t.LtE()
gt = token(">") -> t.Gt()
gte = token(">=") -> t.GtE()
is = keyword("is") -> t.Is()
isnot = keyword("is") keyword("not") -> t.IsNot()
in = keyword("in") -> t.In()
notin = keyword("not") keyword("in") -> t.NotIn()

# 5.10
or_test = or_test:left keyword("or") and_test:right
          -> t.BoolOp(left, t.Or(), right)
        | and_test
and_test = and_test:left keyword("and") not_test:right
           -> t.BoolOp(left, t.And(), right)
         | not_test
not_test = keyword("not") not_test:e -> t.Not(e) | comparison

# 5.11
conditional_expression = or_test:left keyword("if") or_test:cond
                         keyword("else") expression:right
                         -> t.IfExp(cond, left, right)
                       | or_test
expression = conditional_expression | lambda_form

# 5.12
lambda_form = keyword("lambda") parameter_list?:p token(":") expression:e
            -> t.Lambda(p, e)

# 5.13
# XXX AST
expression_list = expression (token(",") expression)* token(",")?
